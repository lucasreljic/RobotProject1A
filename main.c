#pragma config(Sensor, S1,     ,               sensorI2CCustom)
#pragma config(Sensor, S2,     ,               sensorI2CCustom9V)
//#pragma config(Sensor, S3,     ,               sensorSONAR)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "mindsensors-ev3smux.h"
#include "EV3Servo-lib-UW.c"
#include "EV3Multiplex.c"
//start of code

const int MOTOR_LEFT = motorD;
const int MOTOR_RIGHT = motorA;
const int MOTOR_LIFT = motorC;
const int MAX_POWER = 70;
const int RIGHT_ULTRA = 0;
const int SIDE_ULTRA = 1;
const int COLOR_SENSOR = 2;
const float TICK_TO_CM = 180/(PI*1.6);//Encoder ticks to CM calculation
const float CM_TO_TICK = (PI*1.6)/180;//Encoder ticks to CM calculation
const float DEG_TO_RAD = PI/180;
const float ULTRA_DEG = 12;
const float SENSOR_OFFSET = 5;

tMSEV3 muxedSensor[3];

void configureSensors();
int rotateRobot(int angle);
void driveUltrasonic(int distance);
void correctiveDrive(int distance);
void LiftPID(int distance);
void driveBoth(int pwrL, int pwrR);
void drive(int pwr);
int rotateAbsolute(int angle);
tEV3SensorTypeMode typeMode[3] = {sonarCM, sonarCM, colorMeasureColor};
int getMuxSensorValue(int i);
void triangulate ();


task main()
{

	clearDebugStream();
	configureSensors();
	if (!initSensor(&muxedSensor[0], msensor_S1_1, typeMode[0]))
  	writeDebugStreamLine("initSensor() failed! for msensor_S1_1");

  if (!initSensor(&muxedSensor[1], msensor_S1_2, typeMode[1]))
  	writeDebugStreamLine("initSensor() failed! for msensor_S1_2");

  if (!initSensor(&muxedSensor[2], msensor_S1_3, typeMode[2]))
  	writeDebugStreamLine("initSensor() failed! for msensor_S1_3");

	while (!getButtonPress(buttonEnter))
	{
		triangulate();
		//while(!getButtonPress(buttonAny))
		//{}
		//if (getButtonPress(buttonLeft))
		//{
		//	triangulate();
	  //}
	}
}


int getMuxSensorValue(int i)
{
	sleep(100);//wait for i2c port
	if (!readSensor(&muxedSensor[i]))
		writeDebugStreamLine("readSensor() failed! for %d", i);
 	if(muxedSensor[i].typeMode == sonarCM)
		return muxedSensor[i].distance;
	else if (muxedSensor[i].typeMode == colorMeasureColor)
		return muxedSensor[i].color;
	return -1;
}
void configureSensors()
{
	// configure servo controller port
	SensorType[S3]=sensorSONAR;
	wait1Msec(50);
	SensorType[S4] = sensorEV3_Gyro;
	wait1Msec(50);
	SensorMode[S4] = modeEV3Gyro_Calibration;
	wait1Msec(50);
	SensorMode[S4] = modeEV3Gyro_RateAndAngle;
	wait1Msec(50);
	return;
}

int rotateRobot(int angle) //rotates robot in place to given angle then stops. Positive angles are clockwise when viewed from above
{
	int lastGyro = getGyroDegrees(S4);
	const float kP = 0.5;//0.26
	const float kI = 0.001;//0.0008
	const float kD = 0.01;//0.23
	const float tolerance = 0.25;
	float error = angle - (getGyroDegrees(S4)-lastGyro);
	float mPower = 0;
	float prevError = 0;
	time1[T1] = 0;
	while (!getButtonPress(buttonEnter) && abs((getGyroDegrees(S4)-lastGyro) - angle) > tolerance)
	{
		error = abs(angle - (getGyroDegrees(S4)-lastGyro));
		mPower = kP*error + kI*((error+prevError)*(time1[T1] + 1)/2) + kD*abs(((error-prevError)/(time1[T1] + 1)));
		if (angle>0)
		{
			driveBoth(-mPower, mPower);
		}
		else
		{
			driveBoth(mPower,-mPower);
		}
		prevError = error;
		displayString(5, "%f",getGyroDegrees(S4));
	}
	drive(0);
	return abs(getGyroDegrees(S4));
}


int rotateAbsolute(int angle) //rotates robot in place to given angle then stops. Positive angles are clockwise when viewed from above
{
	const float kP = 0.5;//0.26
	const float kI = 0.001;//0.0008
	const float kD = 0.01;//0.23
	const float tolerance = 0.25;
	float error = angle - (getGyroDegrees(S4));//
	float mPower = 0;
	float prevError = 0;
	time1[T1] = 0;// reset timer for PID loop
	while (!getButtonPress(buttonEnter) && abs((getGyroDegrees(S4)) - angle) > tolerance)
	{
		error = angle - getGyroDegrees(S4);// error for turn PID
		mPower = kP*error + kI*((error+prevError)*(time1[T1] + 1)/2) + kD*abs(((error-prevError)/(time1[T1] + 1)));// turn PID calculation
		driveBoth(-mPower, mPower);// turn motors based on motor power from PID with one being negative
		prevError = error;// previous error for PID
		displayString(5, "%f",getGyroDegrees(S4));
	}
	drive(0);
	return abs(getGyroDegrees(S4));
}

void driveUltrasonic(int distance)
{

	nMotorEncoder[motorA] = 0;
	float error = distance - nMotorEncoder[motorA]*TICK_TO_CM;
	int inverted = 1;
	const float tolerance = 0.5;
	float sensorDistance = 0;
	float threshold = SensorValue[S2] - 5;
	while (!getButtonPress(buttonEnter) && !(SensorValue[S2] < threshold))
	{
		sensorDistance = SensorValue[S2];
		displayString(7, "%f",SensorValue[S2]);
		if(abs(error) < tolerance)
		{
			inverted *= -1;
		}

		error = distance - (nMotorEncoder[motorA]/TICK_TO_CM)*inverted;
		drive(20*inverted);
	}
	if(SensorValue[S2] < threshold)
	{
		sensorDistance = SensorValue[S2];
		writeDebugStreamLine("%f", sensorDistance);
		drive(0);
		correctiveDrive(SENSOR_OFFSET + sin(ULTRA_DEG*PI/180)*sensorDistance);
		rotateRobot(-90);
		correctiveDrive(sensorDistance);
	}
	drive(0);
}

void correctiveDrive(int distance)
{
	//Driving PID Constants
	const float kP = 1;
	const float kI = 0.001;
	const float kD = 0.02;
	//Turn PID Constants
	const float turnkP = 0.5;//0.26
	const float turnkI = 0.0005;//0.0008
	const float turnkD = 0.01;//0.23
	float angle = getGyroDegrees(S4);//get angle before driving starts
	float turnError = 0;
	float mTurnPower = 0;
	float turnPrevError = 0;
	const float tolerance = 0.5;
	nMotorEncoder[MOTOR_RIGHT] = 0;
	nMotorEncoder[MOTOR_LEFT] = 0;
	float mPower = 0;
	float prevError = 0;
	int inverted = 1;
	time1[T1] = 0;// start timer for PID loop
	if (distance < 0)// allows for negative direction
	{
		inverted = -1;
	}
	float error = distance*inverted;
	float distanceTravelled = 0;
	while (!getButtonPress(buttonEnter) && abs(error) > tolerance)
	{
		if(nMotorEncoder[MOTOR_RIGHT] > nMotorEncoder[MOTOR_LEFT])// takes the lowest encoder value
		{
			distanceTravelled = nMotorEncoder[MOTOR_LEFT]/TICK_TO_CM;
		}
		else
		{
			distanceTravelled = nMotorEncoder[MOTOR_RIGHT]/TICK_TO_CM;
		}
		turnError = angle - getGyroDegrees(S4);// Turn PID error
		mTurnPower = turnkP*turnError + turnkI*((turnError+turnPrevError)*(time1[T1] + 1)/2) + turnkD*(turnError-turnPrevError);// turn pid calculation
		error = (distance - distanceTravelled)*inverted;// Drive PID error

		mPower = kP*error + kI*((error+prevError)*(time1[T1] + 1)/2) + kD*abs(((error-prevError)/(time1[T1] + 1)));// drive PID calculation
		if(mPower > MAX_POWER)
		{
			mPower = MAX_POWER;
		}
		driveBoth((mPower*inverted -mTurnPower), (mPower*inverted +mTurnPower));//add turn power to drive power to adjust for
		displayString(5, "%f",getGyroDegrees(S4));// printing Gyro Degrees
		prevError = error;// for PID
		turnPrevError = turnError;// for Turn PID
		displayString(7, "%f",mPower);
		displayString(9, "%f",error);
	}
	rotateAbsolute(angle);
	drive(0);// stop motors
}
void driveBoth(int pwrL, int pwrR)
{
	motor[MOTOR_LEFT] = pwrL;
	motor[MOTOR_RIGHT] = pwrR;
}


void drive(int pwr)
{
	motor[MOTOR_LEFT] = motor[MOTOR_RIGHT] = pwr;
}
void LiftPID(int distance)
{
	const float kP = 0.55;
	const float kI = 0.005;
	const float kD = 0.05;
	const float tolerance = 0.5;
	nMotorEncoder[MOTOR_LIFT] = 0;
	float error = distance - nMotorEncoder[MOTOR_LIFT]*TICK_TO_CM;
	displayString(5, "%f",error);
	float mPower = 0;
	float prevError = 0;
	time1[T1] = 0;
	while (!getButtonPress(buttonEnter) && abs(error) > tolerance)
	{
		error = distance - nMotorEncoder[MOTOR_LIFT]/TICK_TO_CM;
		mPower = kP*error + kI*((error+prevError)*(time1[T1] + 1)/2) + kD*abs(((error-prevError)/(time1[T1] + 1)));
		displayString(7, "%f",mPower);
		displayString(5, "%f",error);
		motor[MOTOR_LIFT] = mPower;
		prevError = error;
	}
	motor[MOTOR_LIFT] = 0;
}

const float triLengthB = 20;

void triangulate()
    {
        int triLengthA = SensorValue[S3];
        int triLengthC = (getMuxSensorValue(RIGHT_ULTRA))/10;
        if(triLengthA == 0 || triLengthC == 0)
        {
        	writeDebugStreamLine("ERROR");
        }
        float gammaInit = (acos((pow(triLengthA, 2) + pow(triLengthB, 2) - pow(triLengthC, 2))/(2*triLengthA*triLengthB)))/DEG_TO_RAD;
        float avgTriLength = (triLengthA + triLengthC)/2;
        float gammaFinal = acos(triLengthB/(2*avgTriLength))/DEG_TO_RAD;
        int deltaGamma = ceil(gammaInit - gammaFinal);
        if(abs(deltaGamma) < 90){

        	rotateRobot(deltaGamma);
      	}
    }
